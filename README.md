The project followed a structured microservices-based development process, starting with defining the system requirements for a collaborative project-management platform that includes authentication, task management, real-time chat, notifications, monitoring, and API gateway orchestration. We began by designing the system architecture using independent microservices — Authentication, Task/Board Service, Chat Service, Notification Service, and API Gateway — all communicating through REST APIs and real-time WebSockets. After setting up the monorepo and Dockerized infrastructure, we implemented MongoDB as our primary database and Docker Compose to orchestrate services like Redis, NGINX load balancer, and MongoDB. We then developed each service step-by-step, beginning with the Auth Service using JWT authentication, followed by the Task/Board Service with user-scoped data access, and load-balanced multiple task instances using NGINX for scaling. We integrated Redis caching into heavy-read endpoints to improve performance, and introduced Prometheus-compatible metrics across all services for observability. The Chat Service was implemented using Socket.IO, room-based communication, JWT-secured websocket connections, and persistent chat history stored in MongoDB. An API Gateway was built using Node.js + http-proxy-middleware to centralize routing, authentication, rate limiting, error handling, and service aggregation. Throughout the process we solved numerous issues including proxy mis-routing, task load-balancing glitches, Redis connection errors inside Docker networking, JWT header propagation issues, and ObjectId casting errors. After stabilizing all microservices, we validated all endpoints via Postman and ensured inter-service communication worked at scale. At the end of backend implementation, we achieved a scalable, observable microservices architecture ready for frontend integration.

![image (1)](https://github.com/user-attachments/assets/2b85b4cd-3fd3-46a2-9ba7-cd838f5f5157)
